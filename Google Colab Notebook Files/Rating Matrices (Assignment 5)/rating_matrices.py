# -*- coding: utf-8 -*-
"""Rating Matrices.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1ftr6pRBn_FcIx6cKV4Ni1kQqOdbEwbVk

## Author: Sidharth Ramanan
### Date: 05/28/22

Refer to each section of this notebook to do the 3 questions from the assignment. Feel free to make a copy of the notebook to run and explore the cells yourself (especially the random walk section), but while answering the questions, try to refer to the cell outputs from this copy since some results are stochastic/non-deterministic and consistent answers would be nice.
"""

import numpy as np
import pandas as pd

ratings_matrix = np.array([[4, None, 3.5, 2, 5],
                           [4.5, None, None, 3, 5],
                           [1, 2, 2, 4, 4.5],
                           [None, 3.5, 4, 4, None],
                           [None, 3, None, 5, None]
                           ])

ratings_df = pd.DataFrame(ratings_matrix, columns=['P1', 'P2', 'P3', 'P4', 'P5'], index=['U1', 'U2', 'U3', 'U4', 'U5'])
ratings_df

"""# Q1: User/User Collaborative Filtering"""

item_ratings = ratings_df.fillna(ratings_df.mean())
item_ratings = item_ratings.T
item_ratings

user_ratings = ratings_df.T.fillna(ratings_df.T.mean())
user_ratings = user_ratings.T
user_ratings

user_ratings_centered = user_ratings.sub(user_ratings.mean(axis=1), axis=0)
user_ratings_centered

item_ratings_centered = item_ratings.sub(item_ratings.mean(axis=1), axis=0)
item_ratings_centered

"""## User Similarities"""

from sklearn.metrics.pairwise import cosine_similarity
user_similarities = pd.DataFrame(cosine_similarity(user_ratings_centered), columns=user_ratings_centered.index, index=user_ratings_centered.index)
user_similarities

"""## Item Similarities"""

from sklearn.metrics.pairwise import cosine_similarity
item_similarities = pd.DataFrame(cosine_similarity(item_ratings_centered), columns=item_ratings_centered.index, index=item_ratings_centered.index)
item_similarities

"""# Q2: Matrix Factorization"""

#Credit: https://towardsdatascience.com/recommendation-system-matrix-factorization-d61978660b4b

import numpy

def matrix_factorization(R, P, Q, K, steps=5000, alpha=0.0002, beta=0.02):
    '''
    R: rating matrix
    P: |U| * K (User features matrix)
    Q: |D| * K (Item features matrix)
    K: latent features
    steps: iterations
    alpha: learning rate
    beta: regularization parameter'''
    Q = Q.T

    for step in range(steps):
        for i in range(len(R)):
            for j in range(len(R[i])):
                if R[i][j] > 0:
                    # calculate error
                    eij = R[i][j] - numpy.dot(P[i,:],Q[:,j])

                    for k in range(K):
                        # calculate gradient with a and beta parameter
                        P[i][k] = P[i][k] + alpha * (2 * eij * Q[k][j] - beta * P[i][k])
                        Q[k][j] = Q[k][j] + alpha * (2 * eij * P[i][k] - beta * Q[k][j])

        eR = numpy.dot(P,Q)

        e = 0

        for i in range(len(R)):

            for j in range(len(R[i])):

                if R[i][j] > 0:

                    e = e + pow(R[i][j] - numpy.dot(P[i,:],Q[:,j]), 2)

                    for k in range(K):

                        e = e + (beta/2) * (pow(P[i][k],2) + pow(Q[k][j],2))
        # 0.001: local minimum
        if e < 0.001:

            break

    return P, Q.T

ratings_df.fillna(0)

R = ratings_df.fillna(0).values
# N: num of User
N = len(R)
# M: num of Item
M = len(R[0])
# Num of Features
K = 3
 
U = np.random.rand(N,K)
V = np.random.rand(M,K)
 
U, V = matrix_factorization(R, U, V, K)

nR = np.dot(U, V.T)

pd.DataFrame(U)

pd.DataFrame(V)

pd.DataFrame(U @ V.T)

"""# Q3: Random Walks"""

ratings_df

from collections import defaultdict
def constructGraph(ratingThreshold, ratings_df):
  Graph = defaultdict(list)
  users = ratings_df.index
  items = ratings_df.columns
  for user in users:
    for item in items:
      if ratings_df.loc[user][item] and ratings_df.loc[user][item] > ratingThreshold:
        Graph[user].append(item)
        Graph[item].append(user)
  return Graph

ratingThreshold = 3
Graph = constructGraph(ratingThreshold, ratings_df)

def randomWalk(Graph, N, user, jumpProb):
  scoreMap = defaultdict(int)
  for _ in range(N):
    currentNode = user
    while np.random.uniform() < jumpProb:
      currentNode = np.random.choice(Graph[currentNode])
    if "P" in currentNode:
      scoreMap[currentNode] += 1
  return scoreMap

query = 'U5'
numWalks = 1000
jumpProb = 0.7
randomWalk(Graph, numWalks, query, jumpProb)